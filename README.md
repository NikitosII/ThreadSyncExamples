# ThreadSyncExamples
![C](https://img.shields.io/badge/C-blue.svg)

Проект демонстрирует различные методы синхронизации потоков. 

## Описание

Проект включает три примера: без синхронизации (чтобы увидеть некорректную работу программы с критическим ресурсом при отсутствии средств синхронизации), с использованием семафоров и с обработкой сигналов.

**file2_1.c**
    
Функции потоков:
  - func1: Функция первого потока. Выводит "1" 10 раз, затем выполняет работу вне критического участка.
  - func2: Функция второго потока. Выводит "2" 10 раз, затем выполняет работу вне критического участка.

Когда вы запустите программу, то увидите следующий результат:
121212121212121212121212121212121212121212121212121212121212121.

То есть критический участок *никак не синхронизируется*, оба потока могут одновременно в нем находиться (каждый в своем).

**file2_2.c**

Изменим file2_1.c, включив перед каждым критическим участком блокирующий вызов «захватить» (семафор), а после каждого критического участка включив вызов «освободить» (семафор).

Глобальные переменные:
- sem_t semaphore: Семафор для синхронизации потоков.
  
Функции потоков:
- func1: Функция первого потока. Использует семафор для входа в критическую секцию, выводит "1" 10 раз, затем выполняет работу вне критического участка.
- func2: Функция второго потока. Использует семафор для входа в критическую секцию, выводит "2" 10 раз, затем выполняет работу вне критического участка.

Когда вы запустите программу, то увидите следующий результат:
111111111122222222221111111111222222222211111111112222222222.

То есть пока один поток находится в своем критическом участке (выводит 1), другой поток не может войти в свой критический участок. Затем первый поток освобождает критический участок (завершает вывод 1) и тем самым позволяет второму потоку войти в свой критический участок – вывод 2. И так далее.

**file2_3.c**

Изменим file2_2.c, заменив блокирующий вызов на цикл while ( 1 ) { } с использованием неблокирующей операции с семафором.

Глобальные переменные:
- sem_t semaphore: Семафор для синхронизации потоков.

Обработчик сигнала:
- sig_handler: Обработчик сигнала SIGINT, который уничтожает семафор и завершает программу.

Функции потоков:
- func1: Функция первого потока. Использует семафор для входа в критическую секцию, выводит "1" 10 раз, затем выполняет работу вне критического участка.
- func2: Функция второго потока. Использует семафор для входа в критическую секцию, выводит "2" 10 раз, затем выполняет работу вне критического участка.

Когда вы запустите программу, то увидите тот же результат:
111111111122222222221111111111222222222211111111112222222222.

В чём различие: В программе file2_2 вы не сможете завершить программу по нажатию enter, потому что в потоках семафоры будут заблокированы и потоки не смогут проверять флаг завершения. 

В этом случае завершить работу программы можно по нажатию клавиш ctrl+c. При нажатии этих клавиш генерируетcz специальный сигнал SIGINT, который прерывает работу программы. Для этого написан обработсик сигнала sig_handler. 

## Использование

1. Склонируйте репозиторий:
    ```sh
    git clone <URL репозитория>
    ```
2. Перейдите в директорию проекта:
    ```sh
    cd <имя директории проекта>
    ```
3. Сделайте скрипт исполняемым:
    ```sh
    chmod +x file2_1.sh file2_2.sh file2_3.sh
    ```
4. Запустите скрипт:
    ```sh
    ./file2_1.sh  # Для примера без синхронизации
    ./file2_2.sh  # Для примера с семафорами
    ./file2_3.sh  # Для примера с обработкой сигналов
    ```

## Структура проекта

- file2_1.c: Пример без синхронизации.
- file2_1.sh: Скрипт для компиляции и запуска file2_1.c.
- file2_2.c: Пример с использованием семафоров.
- file2_2.sh: Скрипт для компиляции и запуска file2_2.c.
- file2_3.c: Пример с обработкой сигналов.
- file2_3.sh: Скрипт для компиляции и запуска file2_3.c.


